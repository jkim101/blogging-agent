"""Pipeline state and data model definitions.

Defines PipelineState (TypedDict) and all Pydantic models used across the pipeline.
See 설계서 §7 for full state design specification.
"""

from __future__ import annotations

from enum import Enum
from typing import TypedDict

from pydantic import BaseModel, Field


# --- Enums ---

class SourceType(str, Enum):
    URL = "url"
    PDF = "pdf"
    YOUTUBE = "youtube"


# --- Blog Configuration ---

class BlogConfig(BaseModel):
    """User-configurable blog post settings injected into agent prompts."""
    word_count: int = 1500
    tone: str = "professional"          # casual, professional, academic, conversational
    target_audience: str = ""           # empty → Research Planner decides
    writing_style: str = "analysis"     # tutorial, opinion, analysis, summary, listicle
    include_code_examples: bool = False
    include_tldr: bool = False
    output_language: str = "both"       # ko-only, en-only, both
    primary_keyword: str = ""           # empty → SEO Optimizer decides
    categories: list[str] = Field(default_factory=list)
    custom_instructions: str = ""

    def format_as_prompt_section(self) -> str:
        """Return BlogConfig as a formatted prompt section string."""
        lines = ["", "## Blog Configuration"]
        lines.append(f"- Word count: {self.word_count}")
        lines.append(f"- Tone: {self.tone}")
        lines.append(f"- Writing style: {self.writing_style}")
        if self.target_audience:
            lines.append(f"- Target audience: {self.target_audience}")
        if self.include_code_examples:
            lines.append("- Include relevant code examples where appropriate")
        if self.include_tldr:
            lines.append("- Include a TL;DR summary at the beginning of the post")
        if self.output_language != "both":
            lines.append(f"- Output language: {self.output_language}")
        if self.custom_instructions:
            lines.append(f"- Additional instructions: {self.custom_instructions}")
        return "\n".join(lines)


class HumanDecision(str, Enum):
    APPROVE = "approve"
    EDIT = "edit"
    REJECT = "reject"


class Verdict(str, Enum):
    PASS = "pass"
    FAIL = "fail"


class Severity(str, Enum):
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"


# --- Pydantic Models ---

class SourceContent(BaseModel):
    """Parsed source content from URL or PDF."""
    source_type: SourceType
    origin: str = Field(description="Original URL or file path")
    title: str = ""
    content: str = ""
    metadata: dict = Field(default_factory=dict)


class OutlineSection(BaseModel):
    """A single section in the blog outline."""
    heading: str
    key_points: list[str] = Field(default_factory=list)


class Outline(BaseModel):
    """Blog post outline generated by Research Planner."""
    topic: str
    angle: str = Field(description="Unique perspective or angle for the post")
    target_audience: str
    key_points: list[str] = Field(default_factory=list)
    structure: list[OutlineSection] = Field(default_factory=list)
    estimated_word_count: int = 1500


class FactCheckIssue(BaseModel):
    """A single fact-check issue found in the draft."""
    claim: str
    issue: str
    severity: Severity
    suggestion: str = ""


class FactCheckResult(BaseModel):
    """Fact checking results for a draft."""
    claims_checked: int = 0
    issues_found: list[FactCheckIssue] = Field(default_factory=list)
    overall_accuracy: float = Field(ge=0.0, le=1.0, default=1.0)
    suggestions: list[str] = Field(default_factory=list)


class FactCheckDiff(BaseModel):
    """Diff between previous and current fact-check results during rewrite loop."""
    resolved: list[str] = Field(default_factory=list)
    new: list[str] = Field(default_factory=list)
    remaining: list[str] = Field(default_factory=list)


class CriticFeedback(BaseModel):
    """Critic evaluation results."""
    verdict: Verdict
    score: int = Field(ge=1, le=10)
    strengths: list[str] = Field(default_factory=list)
    weaknesses: list[str] = Field(default_factory=list)
    specific_feedback: str = ""
    rewrite_instructions: str = ""


class SEOMetadata(BaseModel):
    """SEO optimization metadata."""
    optimized_title: str = ""
    meta_description: str = ""
    primary_keyword: str = ""
    secondary_keywords: list[str] = Field(default_factory=list)
    suggested_slug: str = ""


class PublishTarget(BaseModel):
    """Publishing target for a specific language."""
    language: str = Field(pattern="^(ko|en)$")
    platform: str = "github_pages"
    publish: bool = False


# --- Pipeline State (TypedDict for LangGraph) ---

class PipelineState(TypedDict, total=False):
    """Central state object shared across all pipeline agents.

    Each agent reads and writes only its designated fields.
    See 설계서 §7.1 for field ownership.
    """
    # Configuration
    blog_config: BlogConfig

    # Source inputs
    sources: list[SourceContent]

    # Research Planner outputs
    research_summary: str
    outline: Outline

    # HITL #1: Outline review
    outline_decision: HumanDecision
    outline_human_notes: str

    # Writer outputs
    draft_ko: str
    draft_en: str
    rewrite_count: int

    # Fact Checker outputs
    fact_check: FactCheckResult
    fact_check_diff: FactCheckDiff

    # Critic outputs
    critic_feedback: CriticFeedback

    # Editor outputs
    edited_draft_ko: str
    edited_draft_en: str

    # SEO Optimizer outputs
    seo_metadata_ko: SEOMetadata
    seo_metadata_en: SEOMetadata
    final_post_ko: str
    final_post_en: str

    # HITL #2: Publish review
    publish_decision: HumanDecision
    publish_targets: list[PublishTarget]

    # Publishing results
    blog_url_ko: str
    blog_url_en: str

    # Pipeline metadata
    current_step: str
